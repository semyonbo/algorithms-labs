# Best of Three

1. Quicksort (Быстрая сортировка)

    Почему лучший:

    * Очень быстро работает на больших объемах данных: средняя сложность. O(N logN)
    * Простая реализация и хорошо подходит для массивов.
    * Преимущество на практике благодаря небольшому количеству операций и оптимизации кэша.

    Когда применять:
    * Если данные в массиве и нет строгих ограничений на память.
    * Когда не требуется стабильность (порядок одинаковых элементов может нарушаться).

    Недостатки:
    * Худший случай O(n^2) (но это решается использованием случайного выбора опорного элемента или других стратегий разбиения).
    * Неэффективен для связных списков.

2. Merge Sort (Сортировка слиянием)

    Почему лучший:

    * Гарантированная временная сложность O(N logN), независимо от структуры данных.
    * Стабильный алгоритм — сохраняет порядок одинаковых элементов.
    * Хорош для сортировки больших структур данных.

    Когда применять:
    * Если требуется стабильность.
	* Если объем данных большой и требуется сортировка на внешних носителях (алгоритм можно реализовать для дисковой памяти).

    Недостатки:
	* Высокая потребность в памяти (￼O(N) дополнительной памяти для временных массивов).
	* Медленнее на небольших массивах по сравнению с Quicksort.

3. Heap Sort (Сортировка кучей)

    Почему лучший:
    * Временная сложность O(N logN) в любых случаях.
    * Малое использование памяти (￼O(1) дополнительной памяти).
    * Простота и предсказуемость.

    Когда применять:
    * Если важно использовать минимально возможное количество дополнительной памяти.
    * Если нужны гарантии времени выполнения.

    Недостатки:
    * Не является стабильным.
    * Хуже использует кэш процессора, чем Quicksort, поэтому медленнее на практике при небольших данных.

Итог:
* Quicksort: когда нужна скорость и массив небольшой/средний.
* Merge Sort: когда важна стабильность и работа с большими данными.
* Heap Sort: когда есть ограничения по памяти.
